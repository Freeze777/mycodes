#include <bits/stdc++.h>
#include <set>
using namespace std;
#define LL long long


vector<int> maximum_density_subgraph(const vector<vector<int> >& G,
		const vector<vector<LL> >& W) {
	int n = G.size();
	LL sum_weights = 0;
	vector<LL> deg(n, 0);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < W[i].size(); ++j)
			deg[i] += W[i][j];
		sum_weights += deg[i];
	}
	sum_weights /= 2;
	LL l = 0, u = sum_weights, mul2 = 0;

	LL p = 1;
	while (p * 2 <= u)
		p *= 2;
	u = p;

	vector<int> res;
	while ((((u - l) * n * (n - 1)) >> mul2) >= 1) {
		//printf("L: %lld U: %lld\n", l,u);
		//printf("\tTRY GUESS %.3lf\n", (u+l)/double(1<<(mul2+1)));
		LL g = u + l;
		bool odd = (u + l) & (1LL);

		init(n + 2); // Construct max-flow network
		const int S = n, T = n + 1;

		for (int i = 0; i < n; ++i) {
			add_edge(S, i, (sum_weights << mul2));
			add_edge(i, T, ((sum_weights - deg[i]) << mul2) + g);
			for (int j = 0; j < G[i].size(); ++j)
				add_edge(i, G[i][j], (W[i][j] << mul2));
		}

		LL mincut = maxflow(S, T);
		//printf("\tMINCUT: %lld SUMW*N %lld\n", mincut, (sum_weights*n)<<mul2);
		assert(mincut <= (sum_weights * n) << mul2);
		if (mincut == ((sum_weights * n)) << mul2) {
			if (odd)
				u = g, l <<= 1, ++mul2;
			else
				u = g >> 1;
		} else {
			if (odd)
				l = g, u <<= 1, ++mul2;
			else
				l = g >> 1;
			res.clear();
			vector<int> vis(n + 2, 0);
			find_min_cut(S, 0, res, vis);
			LL weight = get_weight(res, G, W);
			//printf("NOW MAX WEIGHT %lld SIZE %d %.3lf\n", weight, res.size(), weight/double(res.size()));
		}
	}
	return res;
}
pair<int, vector<int> > solve(int n, const vector<pair<int, int> >& e,
		const vector<pair<LL, LL> >& ew) {
	int m = e.size();

	LL denom = 1;
	for (int i = 0; i < e.size(); ++i) {
		denom = lcm(denom, ew[i].second);
	}

	LL sum = 0;
	for (int i = 0; i < m; ++i)
		sum += ew[i].first * (denom / ew[i].second);

	if (sum != (n - 1) * denom) { // if the sum of all edges is not n-1
		return make_pair(FAIL_SUM, vector<int>());
	}

	vector<vector<int> > G(n);
	vector<vector<LL> > W(n);
	for (int i = 0; i < m; ++i) {
		int a = e[i].first, b = e[i].second;
		LL w = ew[i].first * (denom / ew[i].second);
		G[a].push_back(b);
		G[b].push_back(a);
		W[a].push_back(w);
		W[b].push_back(w);
	}

	vector<int> res = maximum_density_subgraph(G, W);

	return make_pair(GST, vector<int>());
}

int main() {
		int n, m;
		scanf("%d %d", &n, &m);
		vector<pair<int, int> > e(m);
		vector<pair<LL, LL> > ew(m);
		for (int i = 0; i < m; ++i) {
			scanf("%d %d", &e[i].first, &e[i].second);
			--e[i].first;
			--e[i].second;
			ew[i].first=1;
			ew[i].second=1;
		}

		pair<int, vector<int> > res = solve(n, e, ew);// faster_solve(n, e, ew);
		if (res.first == FAIL_SUM)
			printf("1\n");
		else if (res.first == FAIL_SUBSET) {
			printf("2\n");
			printf("%d\n", res.second.size());
			for (int i = 0; i < res.second.size(); ++i) {
				if (i != 0)
					printf(" ");
				printf("%d", res.second[i] + 1);
			}
			printf("\n");
		} else {
			assert(res.first == GST);
			printf("GST\n");
		}
		printf("\n");

}
