#include <cstdio>
#include <climits>
#include <algorithm>
#include <vector>
#include <map>
#include <cstring>
using namespace std;

typedef pair<int, int> pii;
const int INF = INT_MAX;
const int MAX = 131072;
const int LOG = 17;

map<int, vector<int>> G;
int root[MAX][LOG], pi[MAX], lvl[MAX];

void dfs(int par, int u, int depth) {
	int sz = G[u].size(), i, v;
	lvl[u] = depth;
	for (i = 0; i < sz; i++) {
		v = G[u][i];
		if (v != par) {
			pi[v] = u;
			dfs(u, v, depth + 1);
		}
	}
}

void calcRoot(int n) {
	int i, j;
	memset(root, -1, sizeof root);
	for (i = 1; i <= n; i++)
		root[i][0] = pi[i];
	for (j = 1; 1 << j < n; j++)
		for (i = 1; i <= n; i++)
			if (root[i][j - 1] != -1)
				root[i][j] = root[root[i][j - 1]][j - 1];
}

int lca(int p, int q) {
	int i, stp;
	if (lvl[p] < lvl[q])
		swap(p, q);
	for (stp = 1; 1 << stp <= lvl[p]; stp++)
		;
	stp--;
	for (i = stp; i >= 0; i--)
		if (lvl[p] - (1 << i) >= lvl[q])
			p = root[p][i];
	if (p == q)
		return p;
	for (i = stp; i >= 0; i--)
		if (root[p][i] != -1 && root[p][i] != root[q][i])
			p = root[p][i], q = root[q][i];
	return pi[p];
}

int find(int p, int t) {
	int i, stp;
	for (stp = 1; 1 << stp <= lvl[p]; stp++)
		;
	stp--;
	for (i = stp; i >= 0; i--)
		if (lvl[p] - (1 << i) >= t)
			p = root[p][i];
	return p;
}

int main() {
	int n, q, u, v;
	scanf("%d%d", &n, &q);
	//n-1 lines
	for (int i = 2; i <= n; i++) {
		scanf("%d", &v);
		G[v].push_back(i);
		G[i].push_back(v);
	}
	//dfs from root
	dfs(-1, 1, 0);
	//DP for lca
	calcRoot(n);

	while (q--) {
		int k;
		scanf("%d", &k);
		if (k == 1) {
			int a;
			scanf("%d", &a);
			printf("%d\n", a);
		} else {
			int a, b;
			scanf("%d%d", &a, &b);
			a = lca(a, b);
			k -= 2;
			while (k-- && a != 1) {
				scanf("%d", &b);
				a = lca(a, b);
			}
			printf("%d\n", a);
		}

	}
	return 0;
}
