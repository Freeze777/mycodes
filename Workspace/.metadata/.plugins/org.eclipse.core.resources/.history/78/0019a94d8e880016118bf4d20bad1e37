package algo.graph;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class DFSWithTimeStamp {
	static int time=1;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int m = sc.nextInt();
		Map<DFSVertex,List<DFSVertex>> adjList = new HashMap<DFSVertex,List<DFSVertex>>();

		for (int i = 0; i < m; i++) {
			DFSVertex x =new DFSVertex(sc.nextInt());
			DFSVertex y = new DFSVertex(sc.nextInt());
			if (adjList.containsKey(x)) {
				if (!adjList.get(x).contains(y))// to avoid repaeted edges
					adjList.get(x).add(y);
			} else {
				List<DFSVertex> xList = new ArrayList<DFSVertex>();
				xList.add(y);
				adjList.put(x, xList);
			}

			// comment these part for directed graphs
			if (adjList.containsKey(y)) {
				if (!adjList.get(y).contains(x))
					adjList.get(y).add(x);
			} else {
				List<DFSVertex> yList = new ArrayList<DFSVertex>();
				yList.add(x);
				adjList.put(y, yList);
			}//

		}
		DFSVertex source = new DFSVertex(sc.nextInt());

		Set<DFSVertex> discovered = new HashSet<DFSVertex>();
		Map<DFSVertex, DFSVertex> parent = new HashMap<DFSVertex, DFSVertex>();

		discovered.add(source);
		parent.put(source, null);
		DepthFirstSearch(source, adjList, discovered, parent);
		
		for (DFSVertex vertex : adjList.keySet()) {
			if (!discovered.contains(vertex)) {
				discovered.add(vertex);
				parent.put(vertex, null);
				DepthFirstSearch(vertex, adjList, discovered, parent);
			}
		}
		//System.out.println(parent);
		System.out.println(discovered.size()==n-1);
		//topologicalSortForDAG(discovered);
	}

	

	private static void DepthFirstSearch(DFSVertex current,
			Map<DFSVertex, List<DFSVertex>> adjList, Set<DFSVertex> discovered,
			Map<DFSVertex, DFSVertex> parent) {
		current.start=time++;
		List<DFSVertex> currList = adjList.get(current);

		for (DFSVertex adjVertex : currList) {
			if (!discovered.contains(adjVertex)) {
				discovered.add(adjVertex);
				parent.put(adjVertex, current);
				DepthFirstSearch(adjVertex, adjList, discovered, parent);
			}

		}
		current.finish=time++;

	}
private static void topologicalSortForDAG(Set<DFSVertex> discovered) {
	Set<DFSVertex> set =new TreeSet<DFSVertex>(discovered);
	System.out.println(set);
	}

}