#include "PlyModel.h"

void PlyModel::draw()
{
  readTexture2Buffer("textures/floor.bmp",64,64);
  GLuint txture;
  glGenTextures(1,txture);
  glBindTexture(GL_TEXTURE_2D, txture);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); //scale linearly when image bigger than texture
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); //scale linearly when image smalled than texture
  glTexImage2D(GL_TEXTURE_2D, 0, 3, texture.sizeX, texture.sizeY, 0,
  GL_RGB, GL_UNSIGNED_BYTE, texture.data);
  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();

  glScalef(scale_factor,scale_factor,scale_factor);
    //glTranslatef(-centroid[0]-shift[0],-centroid[1]-shift[1],-centroid[2]-shift[2]);
  glTranslatef(-centroid[0]+shift[0],-centroid[1]+shift[1],-centroid[2]+shift[2]);

    //glColor3f(0.75,0.68,0.204);

    glColor3f(1,1,1);
    int fcount=ply->getFaceCount();
    PlyUtility::Face ** fl=ply->getFaceList();
    PlyUtility::Vertex ** vl=ply->getVertexList();
    for (int var = 0; var < fcount ; var++) {

        if(fl[var]->nverts==3)
        glBegin(GL_TRIANGLES);
        else if(fl[var]->nverts==4)
        glBegin(GL_QUADS);

       glNormal3d(normals[var].x(),normals[var].y(),normals[var].z());

        for (int t = 0; t < fl[var]->nverts; t++)
        {
            int vIndex=fl[var]->verts[t];
	   // glNormal3d(normals[var].x(),normals[var].y(),normals[var].z());
	    glTexCoord2f(vl[vIndex]->x/ply->vx_max,vl[vIndex]->y/ply->vy_max);
            glVertex3f(vl[vIndex]->x,vl[vIndex]->y,vl[vIndex]->z);
        }

        glEnd();
    }



    glPopMatrix();



}


void PlyModel::computeNormal(){


    int fcount=ply->getFaceCount();
    PlyUtility::Face ** fl=ply->getFaceList();
    PlyUtility::Vertex ** vl=ply->getVertexList();

    normals=(Vector *)malloc(sizeof(Vector)*fcount);
    for (int var = 0; var < fcount; ++var) {

        PlyUtility:: Vertex v1=*vl[fl[var]->verts[0]];
        PlyUtility::Vertex v2=*vl[fl[var]->verts[1]];//automatic storage i.e stack..! since new() is not used
        PlyUtility:: Vertex v3=*vl[fl[var]->verts[2]];
        PlyUtility:: Vertex v4;
        if(fl[var]->nverts==4)
        v4=*vl[fl[var]->verts[3]];

        Vector vec21(v2.x-v1.x,v2.y-v1.y,v2.z-v1.z);
        Vector normv;
        if(fl[var]->nverts==3){
        Vector vec32(v3.x-v2.x,v3.y-v2.y,v3.z-v2.z);
       // normv=cross(vec32,vec21);
         normv=cross(vec21,vec32);
        }else if(fl[var]->nverts==4){
        Vector vec41(v4.x-v1.x,v4.y-v1.y,v4.z-v1.z);
        normv=cross(vec21,vec41);
        }

        normv.normalize();
        normals[var]=normv;

    }
}
void PlyModel::readTexture2Buffer(char *filename,int width,int height){

texture.loadTexture(filename);

}



void PlyModel::setShift(GLfloat *s){

shift[0]=s[0];
shift[1]=s[1];
shift[2]=s[2];

}
void PlyModel::computeCentroid(){

centroid[0]=(ply->vx_max+ply->vx_min)/2.0;
centroid[1]=(ply->vy_max+ply->vy_min)/2.0;
centroid[2]=(ply->vz_max+ply->vz_min)/2.0;


}
void PlyModel::computeScaleFactor(float dim){
float maxDiff=0.0;
float dx=ply->vx_max-ply->vx_min;
float dy=ply->vy_max-ply->vy_min;
float dz=ply->vz_max-ply->vz_min;
if(dx>dy)
{
if(dx>dz)
maxDiff=dx;
else
maxDiff=dz;

}else{
if(dy>dz)
maxDiff=dy;
else
maxDiff=dz;

}

scale_factor=dim/maxDiff;

}

